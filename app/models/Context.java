package models;

import play.db.*;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;F
import java.sql.Statement;

import java.util.Collections;
import java.util.Comparator;

import java.util.ArrayList;
import java.util.List;

public class Context {

	public String id, title, unCutCtxt;		//unCutCtxt :	citation context (whole)
	public String Ctxt_upperparg;	//	citation context (left part)
	public String Ctxt_number;		//	citation context (citation number)
	public String Ctxt_lowerparg;	//	citation context (right part)
	public int weight;

	/*
	 * Connection: A connection (session) with a specific database.
	               SQL statements are executed and results are returned within the context of a connection.
	 * ResultSet : A table of data representing a database result set,
	               which is usually generated by executing a statement that queries the database.
	 * Statement : The object used for executing a static SQL statement and returning the results it produces.
	 */

	/* execute SQL statement and return the context(ResultSet) of the connection */
	private static ResultSet execute(Connection connection, String query) {
		ResultSet result = null;
		Statement statement = null;
		try {
			statement = connection.createStatement();
			result = statement.executeQuery(query);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return result;
	}

	public static List<Context> findByPaperid(String paperid) {
		List<Context> ret = new ArrayList<Context>();
		try {
				//Returns a connection from the default datasource, with auto-commit enabled.
				Connection connection = DB.getConnection();

				String q_cit = "Select id,title from citations where paperid ='" + paperid + "';";
				ResultSet cit = execute(connection, q_cit);

				while (cit.next()) {
					Context p = new Context();
					p.id = cit.getString("id");							// citation id
					p.title = cit.getString("title"); 					// citation title

					String q_citxt = "Select context from citationcontexts where citationid='" + p.id + "'";
					ResultSet citxt = execute(connection, q_citxt);

					while (citxt.next()) {
						p.unCutCtxt = citxt.getString("context");		//citation context

						String[] CutCtxt = separate(p.unCutCtxt);

						p.Ctxt_upperparg = CutCtxt[0];
						p.Ctxt_number = CutCtxt[1];
						p.Ctxt_lowerparg = CutCtxt[2];
					}

					String q_ptitle = "Select title from papers where id='" + paperid + "'limit 1";
					ResultSet ptitle = execute(connection, q_ptitle);

					while (ptitle.next()) {
						String papertitle = ptitle.getString("title");
						p.weight = weighting(papertitle, p.unCutCtxt);		//	citation order which is designed by weight functionn
					}

					ret.add(p);
				}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally{
			connection.close();
		}
		// sort the list of citation contexts in term of weight
        Collections.sort(ret,
			new Comparator<Context>() {
            public int compare(Context o1, Context o2) {
                return o2.weight-o1.weight;
            }
        });
		return ret;
	}
	/* weighting method :
	 *
	 * decide the weight of each citation context of a paper
	 * according to the similarity between the paper title
	 * and the content of each citation context
	 */
	public static int weighting(String string1, String string2){
			int term_count = 1;
			int factor = 0;
			try{
				if (string2.length() >0){
					String stim_string1 = string1.toLowerCase(); 	// Stimming string1
					String[] arr_string1 = stim_string1.split(" ");	// Split string1
					arr_string1 = stopfilter(arr_string1);			// remove stop word

					String match = string2;
					String stim_match = match.toLowerCase();		// Stimming string1
					String[] arr_match = stim_match.split(" ");		// Split string1
					arr_match = stopfilter(arr_match);				// remove stop word
					factor = arr_match.length;

					for (int i = 0; i < arr_string1.length; i++){
					int sum = 0;
						for (int j = 0; j < arr_match.length; j++){
							if(arr_match[j].equals(arr_string1[i])){
								sum = sum + 1;
							}else{
								sum = sum;
							}
						}
						term_count = term_count + sum;
					}
					term_count = term_count*200/factor; 		// normalization by the length of citation context
				}else{
					term_count  = 0;
				}
			} catch (NullPointerException e) {
				e.printStackTrace();
			}
				return term_count;
		}

		// stop word filtering
		public static String[] stopfilter(String[] input){
			String stopword[] = {"a", "about", "above", "above", "across", "after",
								"afterwards", "again", "against", "all", "almost",
								"alone", "along", "already", "also","although","always",
								"am","among", "amongst", "amoungst", "amount",
								"an", "and", "another", "any","anyhow","anyone",
								"anything","anyway", "anywhere", "are", "around",
								"as",  "at", "back","be","became", "because",
								"become","becomes", "becoming", "been", "before",
								"beforehand", "behind", "being", "below", "beside",
								"besides", "between", "beyond", "bill", "both",
								"bottom","but", "by", "call", "can", "cannot",
								"cant", "co", "con", "could", "couldnt", "cry",
								"de", "describe", "detail", "do", "done", "down",
								"due", "during", "each", "eg", "eight", "either",
								"eleven","else", "elsewhere", "empty", "enough",
								"etc", "even", "ever", "every", "everyone", "everything",
								"everywhere", "except", "few", "fifteen", "fify", "fill",
								"find", "fire", "first", "five", "for", "former", "formerly",
								"forty", "found", "four", "from", "front", "full", "further",
								"get", "give", "go", "had", "has", "hasnt", "have", "he", "hence",
								"her", "here", "hereafter", "hereby", "herein", "hereupon", "hers",
								"herself", "him", "himself", "his", "how", "however", "hundred",
								"ie", "if", "in", "inc", "indeed", "interest", "into", "is", "it",
								"its", "itself", "keep", "last", "latter", "latterly", "least",
								"less", "ltd", "made", "many", "may", "me", "meanwhile", "might",
								"mill", "mine", "more", "moreover", "most", "mostly", "move", "much",
								"must", "my", "myself", "name", "namely", "neither", "never",
								"nevertheless", "next", "nine", "no", "nobody", "none", "noone",
								"nor", "not", "nothing", "now", "nowhere", "of", "off", "often", "on",
								"once", "one", "only", "onto", "or", "other", "others", "otherwise",
								"our", "ours", "ourselves", "out", "over", "own","part", "per", "perhaps",
								"please", "put", "rather", "re", "same", "see", "seem", "seemed", "seeming",
								"seems", "serious", "several", "she", "should", "show", "side", "since",
								"sincere", "six", "sixty", "so", "some", "somehow", "someone", "something",
								"sometime", "sometimes", "somewhere", "still", "such", "system", "take",
								"ten", "than", "that", "the", "their", "them", "themselves", "then",
								"thence", "there", "thereafter", "thereby", "therefore", "therein",
								"thereupon", "these", "they", "thickv", "thin", "third", "this", "those",
								"though", "three", "through", "throughout", "thru", "thus", "to", "together",
								"too", "top", "toward", "towards", "twelve", "twenty", "two", "un", "under",
								"until", "up", "upon", "us", "very", "via", "was", "we", "well", "were",
								"what", "whatever", "when", "whence", "whenever", "where", "whereafter",
								"whereas", "whereby", "wherein", "whereupon", "wherever", "whether", "which",
								"while", "whither", "who", "whoever", "whole", "whom", "whose", "why", "will",
								"with", "within", "without", "would", "yet", "you", "your", "yours", "yourself",
								"yourselves", "the"};

			int stoplength = stopword.length;
			int inputlength = input.length;
			List<String> output = new ArrayList<String>();
			
			// flag for deciding whether this word is added to list or not
			boolean isStop = false; 
			
			// Naive method: O(n^2)
			for (int i = 0; i < inputlength; i++){ // loop for each word in input string array
				for (int j = 0; j < stoplength; j++){ // scanning each word in stop word array
					if(input[i].equals(stopword[j])){
						isStop = true;
						break;
					}else{
						isStop = false;
					}
				}
				// add to list if this word is not a stop word
				if(isStop == false) output.add(input[i]);
			}
			return output.toArray();
		}


	public static String[] separate(String context){
		String[] output = new String [3];
		int breakpoint = 0;
		int breakpoint1 = 0;

		String[] arr = context.split("=-=");
		String[] arr1 = arr[1].split("-=-");

		String upperparagraph = arr[0];
		String citednumber = arr1[0];
		String lowerparagraph = arr1[1];

		String[] upp_arr = upperparagraph.split(" ");


		for (int i = 0; i < upp_arr.length; i++ )
		{
			String s = upp_arr[i];
			if (s.length() >0){
				if ( s.charAt(s.length()-1) =='.')
				{
					breakpoint = i;
					break;
				}
			}
		}
		String concatString = upp_arr[breakpoint+1];
		for (int i = (breakpoint+2); i <upp_arr.length; i++)
			concatString = concatString.concat(" " + upp_arr[i] );

		String[] low_arr = lowerparagraph.split(" ");
		for (int i = 0; i < low_arr.length; i++ )
		{
				String s = low_arr[low_arr.length-1-i];
				if (s.length() >0){
					if ( s.charAt(s.length()-1) =='.')
					{
						breakpoint1 = low_arr.length-1-i;
						break;
					}
				}
			}
		String concatString1 = low_arr[0];
		for (int i = 1; i <=breakpoint1; i++)
			concatString1= concatString1.concat(" " + low_arr[i] );

		// process citednumber

		String addtail = "";
		String addhead = "";
		boolean existbracket = false;
		boolean existLeftB = false;
		boolean existRightB = false;
		char leftbracket = '\0';
		char rightbracket = '\0';


		for (int i = 0; i < citednumber.length(); i++)
		{
			if ( citednumber.charAt(i) =='[' || citednumber.charAt(i) ==']' ){
				leftbracket = '[';
				rightbracket = ']';
				existbracket = true;
			}
			if ( citednumber.charAt(i) =='(' || citednumber.charAt(i) ==')' ){
				leftbracket = '(';
				rightbracket = ')';
				existbracket = true;
			}
		}
		if (existbracket){
			for (int i = 0; i < citednumber.length(); i++)
			{
				if ( citednumber.charAt(i) ==leftbracket)
					existLeftB = true;
				if ( citednumber.charAt(i) ==rightbracket)
					existRightB = true;
			}

			if (existLeftB){   // "[" exist
				if  ( citednumber.charAt(0) !=leftbracket){ // "[" is not the first position

					String[] arr_mid = citednumber.split("\\"+leftbracket);
					addtail = arr_mid[0];
					if(existRightB){ // "]" exists
						if  ( citednumber.charAt(citednumber.length()-1) != rightbracket){ // "]" is not at the end position
							String[] arr_mid1 = arr_mid[1].split("\\"+rightbracket);
							citednumber = leftbracket + arr_mid1[0] +rightbracket;
							if ( arr_mid1.length > 1)
								addhead = arr_mid1[1];

						}else{ // "]" is at the end position
							citednumber =  leftbracket + arr_mid[1];
						}
					}else{ // "]" doesn't exists
						citednumber =   leftbracket + arr_mid[1];
					}
				} else { //"[" is at the first position

					if(existRightB){ // "]" exists
						if  ( citednumber.charAt(citednumber.length()-1) !=rightbracket){ // "]" is not at the end of citednumber

							String[] arr_mid1 = citednumber.split("\\"+rightbracket);
							citednumber = arr_mid1[0] + rightbracket;
							addhead = arr_mid1[1];
						}else{ // "]" is at the end of citednumber.
							citednumber = citednumber;
						}
					}else{ // "]" doesn't exists
						citednumber = citednumber;
					}

				}
			}else{//"[" doesn't exist
				if(existRightB){ // "]" exists
						if  ( citednumber.charAt(citednumber.length()-1) !=rightbracket){ // "]" is not at the end of citednumber

							String[] arr_mid1 = citednumber.split("\\"+rightbracket);
							citednumber = arr_mid1[0] + rightbracket;
							addhead = arr_mid1[1];
						}else{ // "]" is at the end of citednumber.
							citednumber = citednumber;
						}
					}else{ // "]" doesn't exists
						citednumber = citednumber;
					}
			}
		}else{
			citednumber = citednumber;
		}
		concatString = concatString.concat(addtail);
		if ( concatString1.length() >0){
		concatString1 = addhead.concat(concatString1);
		}else{
		concatString1 = " .".concat(concatString1);
		}

		output[0] = concatString;
		output[1] = citednumber;
		output[2] = concatString1;
		return output;

	}

}
